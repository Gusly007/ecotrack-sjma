# ============================================================================
# GITHUB ACTIONS CI/CD PIPELINE
# ============================================================================
#
# CONCEPT: Automatise lint → test → build → scan à chaque push/PR
#
# TRIGGER: S'exécute sur:
#   - Push sur main, develop, feature/* branches
#   - Pull request ouvert/modifié
#
# JOBS:
#   1. Code Quality (Lint) - ESLint, indentation, etc.
#   2. Unit Tests - Jest avec couverture
#   3. Security Scan - npm audit (vulnérabilités)
#   4. Build Docker - Construit l'image du service-users
#   5. Test Docker - Lance le conteneur et le valide
#
# RÉSULTAT: PR est "blocked" si un job échoue (protection)
# ============================================================================

name: 'CI/CD Pipeline'

# Déclenche ce workflow
on:
  push:
    branches:
      - main
      - develop
      - 'feature/**'
  pull_request:
    branches:
      - main
      - develop

# Variables env globales pour ce workflow
env:
  REGISTRY: ghcr.io  # GitHub Container Registry (public registry GitHub)

jobs:
  # =========================================================================
  # JOB 1: CODE QUALITY (LINT) - TOUS LES SERVICES
  # =========================================================================
  # Vérifie que le code respecte les normes (indentation, syntax, etc.)
  
  lint:
    name: 'Lint Code - ${{ matrix.service }}'
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        service: ['service-users', 'api-gateway']
    
    steps:
      # Étape 1: Télécharger le code du repo
      - name: 'Checkout code'
        uses: actions/checkout@v4
      
      # Étape 2: Installer Node.js
      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'services/${{ matrix.service }}/package-lock.json'
      
      # Étape 3: Installer dépendances
      - name: 'Install dependencies'
        run: npm ci
        working-directory: services/${{ matrix.service }}
      
      # Étape 4: Lancer ESLint (si config existe)
      - name: 'Run ESLint'
        run: npx eslint src/ --max-warnings 10 || echo "ESLint not configured"
        working-directory: services/${{ matrix.service }}
        continue-on-error: true

  # =========================================================================
  # JOB 2: UNIT TESTS - SERVICE-USERS SEULEMENT (a des tests)
  # =========================================================================
  # Lance Jest, collecte la couverture de code
  
  test:
    name: 'Unit Tests - service-users'
    runs-on: ubuntu-latest
    
    # Dépend du lint (lint doit réussir en premier)
    needs: lint
    
    services:
      # Service PostgreSQL utilisé durant les tests
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
          POSTGRES_DB: ecotrack_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: 'Checkout code'
        uses: actions/checkout@v4
      
      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'services/service-users/package-lock.json'
      
      - name: 'Install dependencies'
        run: npm ci
        working-directory: services/service-users
      
      # Lance Jest avec couverture
      - name: 'Run Jest tests'
        run: npm run test:coverage
        working-directory: services/service-users
        env:
          # Base de test dans le service postgres ci-dessus
          DATABASE_URL: postgresql://test_user:test_pass@localhost:5432/ecotrack_test
          NODE_ENV: test
          ACCESS_TOKEN_SECRET: test_secret_access
          REFRESH_TOKEN_SECRET: test_secret_refresh
      
      # Upload couverture vers Codecov (optionnel, visualiser la couverture)
      - name: 'Upload coverage to Codecov'
        uses: codecov/codecov-action@v3
        with:
          file: ./services/service-users/coverage/coverage-final.json
          flags: unittests
        continue-on-error: true

  # =========================================================================
  # JOB 3: SECURITY SCAN - TOUS LES SERVICES
  # =========================================================================
  # Détecte les vulnérabilités dans les dépendances
  
  security:
    name: 'Security Scan - ${{ matrix.service }}'
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        service: ['service-users', 'api-gateway']
    
    steps:
      - name: 'Checkout code'
        uses: actions/checkout@v4
      
      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'services/${{ matrix.service }}/package-lock.json'
      
      - name: 'Install dependencies'
        run: npm ci
        working-directory: services/${{ matrix.service }}
      
      # npm audit = audit les dépendances pour vulnérabilités
      - name: 'Run npm audit'
        run: npm audit --production
        working-directory: services/${{ matrix.service }}
        continue-on-error: true
      
      # Optionnel: Snyk scan (si tu as un compte Snyk)
      # - name: 'Run Snyk scan'
      #   run: npx snyk test
      #   working-directory: service-users
      #   env:
      #     SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # =========================================================================
  # JOB 4: BUILD DOCKER - TOUS LES SERVICES
  # =========================================================================
  # Construit les images Docker pour service-users et api-gateway
  
  build:
    name: 'Build Docker - ${{ matrix.service }}'
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        include:
          - service: service-users
            image-name: ecotrack-service-users
            port: 3010
          - service: api-gateway
            image-name: ecotrack-api-gateway
            port: 3000
    
    # Attend que les tests réussissent
    needs: test
    
    # Permissions pour pousser sur le registry
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: 'Checkout code'
        uses: actions/checkout@v4
      
      # Setup buildx pour build multi-platform (ARM64, AMD64, etc.)
      - name: 'Set up Docker Buildx'
        uses: docker/setup-buildx-action@v3
      
      # Login au GitHub Container Registry (pour pousser l'image)
      - name: 'Log in to Container Registry'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Métadonnées pour le tag de l'image
      - name: 'Extract metadata'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.image-name }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
      
      # Build et push l'image Docker
      - name: 'Build and push Docker image'
        uses: docker/build-push-action@v5
        with:
          context: ./services/${{ matrix.service }}
          push: ${{ github.event_name != 'pull_request' }}  # Push sauf en PR
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # =========================================================================
  # JOB 5: TEST DOCKER IMAGE - TOUS LES SERVICES
  # =========================================================================
  # Lance le conteneur Docker construit et valide qu'il démarre
  
  test-docker:
    name: 'Test Docker - ${{ matrix.service }}'
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        include:
          - service: service-users
            image-name: ecotrack-service-users
            port: 3010
            env-vars: '-e APP_PORT=3010 -e JWT_SECRET=test -e JWT_REFRESH_SECRET=test -e DATABASE_URL=postgresql://test_user:test_pass@172.17.0.1:5432/ecotrack_test'
          - service: api-gateway
            image-name: ecotrack-api-gateway
            port: 3000
            env-vars: '-e GATEWAY_PORT=3000 -e USERS_SERVICE_URL=http://localhost:3010'
    
    needs: build
    if: github.event_name == 'pull_request'  # Seulement en PR
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
          POSTGRES_DB: ecotrack_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: 'Checkout code'
        uses: actions/checkout@v4
      
      - name: 'Set up Docker Buildx'
        uses: docker/setup-buildx-action@v3
      
      # Initialize database schema for service-users
      - name: 'Initialize database schema'
        if: matrix.service == 'service-users'
        working-directory: services/service-users
        run: |
          sudo apt-get update && sudo apt-get install -y postgresql-client
          export PGPASSWORD=test_pass
          ls -la sql/
          psql -h localhost -U test_user -d ecotrack_test -f sql/EcoTrack.sql
      
      # Build localement l'image (sans push)
      - name: 'Build Docker image'
        uses: docker/build-push-action@v5
        with:
          context: ./services/${{ matrix.service }}
          load: true
          tags: ${{ matrix.image-name }}:test
      
      # Lance le conteneur et teste /health endpoint
      - name: 'Start container and test health'
        run: |
          docker run -d \
            --name test-container \
            -p ${{ matrix.port }}:${{ matrix.port }} \
            ${{ matrix.env-vars }} \
            ${{ matrix.image-name }}:test
          
          # Attendre que le container démarre avec retry
          echo "Waiting for container to start..."
          for i in {1..30}; do
            if curl -f http://localhost:${{ matrix.port }}/health 2>/dev/null; then
              echo "Container is healthy!"
              break
            fi
            echo "Attempt $i/30 failed, retrying in 2s..."
            sleep 2
          done
          
          # Vérifier une dernière fois
          curl -f http://localhost:${{ matrix.port }}/health || {
            echo "Health check failed. Container logs:"
            docker logs test-container
            exit 1
          }
          
          echo "Health check passed!"
          docker logs test-container
          docker stop test-container

# ============================================================================
# RÉSUMÉ WORKFLOW
# ============================================================================
# 
# Quand tu fais: git push
#   → GitHub Actions détecte le push
#   → Lance tous les jobs en parallèle (lint, test, security, build)
#   → Si l'un échoue, l'image ne se build pas
#   → Résultats visibles dans GitHub "Actions" tab
#
# En production:
#   - CD: l'image "latest" se déploie auto sur K8s
#   - Monitoring alerte si deployment échoue
#
# Coûts GitHub Actions:
#   - 2000 min/mois gratuit pour repos public
#   - Payant au-delà
